<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ - v2.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* UI å®¹å™¨ */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
        }

        /* é€šç”¨é¢æ¿æ ·å¼ */
        .panel {
            background: rgba(20, 20, 20, 0.75);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 15px;
            color: white;
            pointer-events: auto;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            max-width: 260px;
        }

        /* çŠ¶æ€æ˜¾ç¤º */
        #status-panel h2 { margin: 0 0 8px 0; font-size: 14px; color: #00d2ff; text-transform: uppercase; letter-spacing: 1px;}
        .status-item { margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; }
        .status-label { font-size: 12px; color: #aaa; }
        .status-value { font-size: 14px; font-weight: bold; font-family: monospace;}

        /* æ§åˆ¶é¢æ¿ */
        #controls-panel { display: flex; flex-direction: column; gap: 12px; }
        .hidden { opacity: 0; transform: translateX(-30px); pointer-events: none; height: 0; padding: 0; margin: 0; overflow: hidden; }

        /* æŒ‰é’®ç½‘æ ¼ */
        .shape-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        button:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-1px); }
        button.active { 
            background: linear-gradient(135deg, #00d2ff 0%, #007aff 100%); 
            color: #fff; 
            border-color: transparent; 
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.4);
        }

        /* æ—‹è½¬æ¨¡å¼åˆ‡æ¢ */
        .toggle-row { display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;}
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #00d2ff; }
        input:checked + .slider:before { transform: translateX(20px); }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        .color-wrapper { display: flex; align-items: center; justify-content: space-between; }
        input[type="color"] { border: none; width: 30px; height: 30px; cursor: pointer; background: none; padding: 0; }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        #webcam-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            transform: scaleX(-1); /* é•œåƒ */
            border: 2px solid rgba(255, 255, 255, 0.1);
            z-index: 5;
            object-fit: cover;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        /* å‡†æ˜Ÿ/ä¸­å¿ƒçº¿è¾…åŠ© */
        #webcam-overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            z-index: 6;
            pointer-events: none;
        }
        .center-line {
            position: absolute;
            left: 50%;
            top: 10%;
            bottom: 10%;
            width: 1px;
            background: rgba(0, 210, 255, 0.5);
            border-left: 1px dashed rgba(0, 210, 255, 0.8);
        }

        /* èœå•å¼€å…³æŒ‰é’® */
        #menu-toggle {
            pointer-events: auto;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        #menu-toggle:hover { color: #00d2ff; border-color: #00d2ff; }

    </style>
    <!-- å¼•å…¥åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-container">
        <button id="menu-toggle" title="åˆ‡æ¢èœå•">â˜°</button>
        
        <div id="status-panel" class="panel">
            <h2>äº¤äº’æ•°æ®æµ</h2>
            <div class="status-item">
                <span class="status-label">å½“å‰æ‰‹åŠ¿</span>
                <span id="gesture-name" class="status-value" style="color: #fff">ç­‰å¾…...</span>
            </div>
            <div class="status-item">
                <span class="status-label">å¼ å¼€å¼ºåº¦ (ç¼©æ”¾)</span>
                <span id="scale-val" class="status-value">0%</span>
            </div>
            <div class="status-item">
                <span class="status-label">æ°´å¹³ä½ç½® (æ—‹è½¬)</span>
                <span id="rotate-val" class="status-value">å±…ä¸­</span>
            </div>
        </div>

        <div id="controls-panel" class="panel">
            <div class="toggle-row">
                <span style="font-size:13px;">æ‰‹åŠ¿æ§åˆ¶æ—‹è½¬</span>
                <label class="switch">
                    <input type="checkbox" id="rotation-mode-check">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="shape-grid">
                <button onclick="setShape('heart')" class="active">â¤ï¸ çˆ±å¿ƒ</button>
                <button onclick="setShape('flower')">ğŸŒ¸ èŠ±æœµ</button>
                <button onclick="setShape('saturn')">ğŸª åœŸæ˜Ÿ</button>
                <button onclick="setShape('buddha')">ğŸ§˜ ä½›åƒ</button>
                <button onclick="setShape('dna')">ğŸ§¬ DNA</button>
                <button onclick="setShape('firework')">ğŸ† çƒŸèŠ±</button>
            </div>
            
            <div class="color-wrapper" style="margin-top:10px; padding: 0 5px;">
                <span style="font-size:13px; color:#ddd;">ç²’å­åŸºè°ƒ</span>
                <input type="color" id="colorPicker" value="#00d2ff">
            </div>
        </div>
    </div>

    <!-- æ‘„åƒå¤´éƒ¨åˆ† -->
    <video id="webcam-preview" playsinline></video>
    <div id="webcam-overlay">
        <div class="center-line"></div>
    </div>

    <script>
        // ================= é…ç½®ä¸å˜é‡ =================
        const CONFIG = {
            particleCount: 18000,
            baseColor: 0x00d2ff,
            lerpSpeed: 0.06,
            defaultRotationSpeed: 0.0015
        };

        let isHandControllingRotation = false; // é»˜è®¤è‡ªåŠ¨æ—‹è½¬
        let targetRotationSpeed = CONFIG.defaultRotationSpeed;
        let currentRotationSpeed = CONFIG.defaultRotationSpeed;
        
        // æ‰‹åŠ¿ç›¸å…³çŠ¶æ€
        let gestureScaleTarget = 1.0;
        let currentScale = 1.0;
        let handCenterX = 0.5; // 0.0 å·¦, 1.0 å³, 0.5 ä¸­

        // ================= Three.js åˆå§‹åŒ– =================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 32;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // ç²’å­ç³»ç»Ÿ
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3);
        
        // åˆå§‹éšæœºä½ç½®
        for (let i = 0; i < CONFIG.particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 150;
            targetPositions[i] = positions[i];
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // æè´¨
        const textureLoader = new THREE.TextureLoader();
        const sprite = textureLoader.load('https://threejs.org/examples/textures/sprites/spark1.png');

        const material = new THREE.PointsMaterial({
            color: CONFIG.baseColor,
            size: 0.35,
            map: sprite,
            transparent: true,
            opacity: 0.85,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // ================= å½¢çŠ¶ç”Ÿæˆé€»è¾‘ =================
        function getShapePoint(type, i, total) {
            // è¿”å›å•ä¸ªç‚¹çš„ x,y,z å¯¹è±¡
            const idx = i;
            const p = i / total; // normalized index 0..1
            
            let x=0, y=0, z=0;

            if (type === 'heart') {
                // Heart Surface
                let t = Math.random() * Math.PI * 2;
                let u = Math.random() * Math.PI;
                let hx = 16 * Math.pow(Math.sin(t), 3);
                let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let hz = 5 * Math.cos(t) * Math.sin(u) * Math.sin(t); // Thickness
                const scale = 0.7 * Math.random(); 
                return { x: hx * scale, y: hy * scale, z: hz * scale * 2 };
            } 
            else if (type === 'flower') {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const k = 5; // 5 petals
                const r = 10 * Math.sin(k * u) * Math.sin(v) + 2; 
                return {
                    x: r * Math.cos(u) * Math.sin(v),
                    y: r * Math.sin(u) * Math.sin(v),
                    z: r * Math.cos(v) * 0.5 // flatten z
                };
            }
            else if (type === 'saturn') {
                if (Math.random() > 0.35) {
                    // Planet
                    const r = 9 * Math.cbrt(Math.random()); 
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    return {
                        x: r * Math.sin(phi) * Math.cos(theta),
                        y: r * Math.sin(phi) * Math.sin(theta),
                        z: r * Math.cos(phi)
                    };
                } else {
                    // Rings
                    const r = 13 + Math.random() * 8;
                    const theta = Math.random() * Math.PI * 2;
                    return {
                        x: r * Math.cos(theta),
                        y: (Math.random()-0.5),
                        z: r * Math.sin(theta)
                    };
                }
            }
            else if (type === 'dna') {
                // Double Helix
                const t = p * Math.PI * 20; // turns
                const radius = 6;
                const height = 30;
                
                // Two strands
                const offset = (i % 2 === 0) ? 0 : Math.PI;
                const yPos = (p - 0.5) * height;
                
                // Add noise
                const noise = (Math.random() - 0.5) * 1.5;
                
                return {
                    x: radius * Math.cos(t + offset) + noise,
                    y: yPos,
                    z: radius * Math.sin(t + offset) + noise
                };
            }
            else if (type === 'buddha') {
                // Abstract stacked spheres
                const rSelector = Math.random();
                let cx=0, cy=0, cz=0, rad=1;
                if (rSelector < 0.35) { cy = -3; rad = 6.5; } // Body
                else if (rSelector < 0.55) { cy = 5; rad = 3.2; } // Head
                else if (rSelector < 0.75) { cx = -4.5; cy = -7; cz = 2.5; rad = 2.8; } // Left Knee
                else { cx = 4.5; cy = -7; cz = 2.5; rad = 2.8; } // Right Knee

                const r = rad * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return {
                    x: cx + r * Math.sin(phi) * Math.cos(theta),
                    y: cy + r * Math.sin(phi) * Math.sin(theta),
                    z: cz + r * Math.cos(phi)
                };
            }
            else { // Firework / Sphere
                const r = 18 * Math.sqrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            }
        }

        function setShape(type) {
            for(let i=0; i<CONFIG.particleCount; i++) {
                const pos = getShapePoint(type, i, CONFIG.particleCount);
                targetPositions[i*3] = pos.x;
                targetPositions[i*3+1] = pos.y;
                targetPositions[i*3+2] = pos.z;
            }
            
            document.querySelectorAll('.shape-grid button').forEach(btn => {
                btn.classList.remove('active');
                if(btn.innerText.toLowerCase().includes(getShapeNameCN(type))) btn.classList.add('active');
            });
        }

        function getShapeNameCN(type) {
            const map = { 'heart':'çˆ±å¿ƒ','flower':'èŠ±æœµ','saturn':'åœŸæ˜Ÿ','buddha':'ä½›åƒ','dna':'dna','firework':'çƒŸèŠ±'};
            return map[type] || '';
        }

        setShape('heart');

        // ================= åŠ¨ç”»å¾ªç¯ =================
        function animate() {
            requestAnimationFrame(animate);

            const posArr = geometry.attributes.position.array;

            // 1. ä½ç½®æ’å€¼ (Morphing)
            for (let i = 0; i < CONFIG.particleCount * 3; i++) {
                posArr[i] += (targetPositions[i] - posArr[i]) * CONFIG.lerpSpeed;
            }
            geometry.attributes.position.needsUpdate = true;

            // 2. æ—‹è½¬æ§åˆ¶é€»è¾‘
            if (isHandControllingRotation) {
                // æ‰‹åŠ¿æ§åˆ¶ï¼šä¸­å¿ƒ(0.5)é™æ­¢ï¼Œå‘å³(>0.5)é¡ºæ—¶é’ˆï¼Œå‘å·¦(<0.5)é€†æ—¶é’ˆ
                // æ˜ å°„èŒƒå›´ï¼š(0 ~ 1) -> (-0.05 ~ 0.05)
                const rotSpeed = (handCenterX - 0.5) * 0.1; 
                // å¹³æ»‘è¿‡æ¸¡
                currentRotationSpeed += (rotSpeed - currentRotationSpeed) * 0.1;
            } else {
                // è‡ªåŠ¨æ—‹è½¬
                currentRotationSpeed += (CONFIG.defaultRotationSpeed - currentRotationSpeed) * 0.05;
            }
            particles.rotation.y += currentRotationSpeed;

            // 3. ç¼©æ”¾å¹³æ»‘é€»è¾‘
            currentScale += (gestureScaleTarget - currentScale) * 0.1;
            particles.scale.set(currentScale, currentScale, currentScale);

            // 4. å¾®åŠ¨æ€ (å‘¼å¸æ„Ÿ)
            if (currentScale > 1.3) {
                const time = Date.now() * 0.001;
                particles.rotation.z = Math.sin(time) * 0.05; // æ™ƒåŠ¨
            } else {
                particles.rotation.z *= 0.95; // å½’ä½
            }

            renderer.render(scene, camera);
        }
        animate();

        // ================= DOM UI äº¤äº’ =================
        const elGestureName = document.getElementById('gesture-name');
        const elScaleVal = document.getElementById('scale-val');
        const elRotateVal = document.getElementById('rotate-val');
        const elMenuToggle = document.getElementById('menu-toggle');
        const elControls = document.getElementById('controls-panel');
        
        // åˆ‡æ¢èœå•
        elMenuToggle.addEventListener('click', () => {
            elControls.classList.toggle('hidden');
        });

        // é¢œè‰²ä¿®æ”¹
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            material.color.set(e.target.value);
        });

        // æ—‹è½¬æ¨¡å¼å¼€å…³
        document.getElementById('rotation-mode-check').addEventListener('change', (e) => {
            isHandControllingRotation = e.target.checked;
            if(!isHandControllingRotation) {
                elRotateVal.innerText = "è‡ªåŠ¨æ—‹è½¬ä¸­";
                elRotateVal.style.color = "#aaa";
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ================= MediaPipe Hands é€»è¾‘ =================
        const videoElement = document.getElementById('webcam-preview');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // 1. è®¡ç®—ç¼©æ”¾ (æ‹‡æŒ‡ä¸å°æŒ‡è·ç¦»)
                const thumb = landmarks[4];
                const pinky = landmarks[20];
                const dist = Math.sqrt(Math.pow(thumb.x - pinky.x, 2) + Math.pow(thumb.y - pinky.y, 2));
                
                // æ˜ å°„è·ç¦»åˆ°ç¼©æ”¾ (0.05~0.4 -> 0.5~2.5)
                let scaleFactor = (dist - 0.05) * 6;
                gestureScaleTarget = Math.max(0.4, Math.min(scaleFactor + 0.5, 3.0));

                // 2. è®¡ç®—æ—‹è½¬ (æ‰‹æŒä¸­å¿ƒçš„ X åæ ‡)
                // ä½¿ç”¨ä¸­æŒ‡æ ¹éƒ¨(9)ä½œä¸ºæ‰‹æŒä¸­å¿ƒè¾ƒä¸ºç¨³å®š
                const handX = landmarks[9].x; 
                // é•œåƒä¿®æ­£ï¼šå¦‚æœæ‘„åƒå¤´æ˜¯é•œåƒçš„ï¼Œx=0åœ¨å·¦è¾¹ï¼Œä½†æˆ‘ä»¬åœ¨cssé‡Œåè½¬äº†video
                // é€šå¸¸ MediaPipe è¾“å‡ºï¼š0(å·¦) -> 1(å³)ã€‚
                // ä¸ºäº†ç›´è§‰ï¼šæ‰‹å¾€å³ç§»(å±å¹•å³è¾¹)ï¼Œæ¨¡å‹å¾€å³è½¬ã€‚
                handCenterX = 1.0 - handX; // åè½¬ä¸€ä¸‹ä»¥åŒ¹é…é•œåƒçš„è§†è§‰ä½“éªŒ

                // 3. UI åé¦ˆæ›´æ–°
                const pct = Math.round(dist * 100);
                elScaleVal.innerText = `${pct}%`;

                // æ‰‹åŠ¿åç§°åé¦ˆ
                if (dist > 0.25) {
                    elGestureName.innerText = "å¼ å¼€ (æ‰©å¼ )";
                    elGestureName.style.color = "#00ff88";
                } else if (dist < 0.1) {
                    elGestureName.innerText = "æ¡æ‹³ (æ”¶ç¼©)";
                    elGestureName.style.color = "#ff4444";
                } else {
                    elGestureName.innerText = "è°ƒæ•´ä¸­";
                    elGestureName.style.color = "#fff";
                }

                // æ—‹è½¬åé¦ˆ
                if (isHandControllingRotation) {
                    const deviation = handCenterX - 0.5;
                    if (deviation > 0.1) {
                        elRotateVal.innerText = `<< å‘å·¦æ—‹è½¬ ${(deviation*100).toFixed(0)}`;
                        elRotateVal.style.color = "#00d2ff";
                    } else if (deviation < -0.1) {
                        elRotateVal.innerText = `${(Math.abs(deviation)*100).toFixed(0)} å‘å³æ—‹è½¬ >>`;
                        elRotateVal.style.color = "#00d2ff";
                    } else {
                        elRotateVal.innerText = "|| å±…ä¸­åœæ­¢";
                        elRotateVal.style.color = "#fff";
                    }
                } else {
                    elRotateVal.innerText = "è‡ªåŠ¨æ¨¡å¼";
                    elRotateVal.style.color = "#aaa";
                }

            } else {
                elGestureName.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
                elGestureName.style.color = "#555";
                // æ— æ‰‹æ—¶ç¼“æ…¢å¤ä½
                gestureScaleTarget = 1.0;
                handCenterX = 0.5; 
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });

        cameraUtils.start();

    </script>
</body>
</html>