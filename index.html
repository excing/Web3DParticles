<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿äº¤äº’ 3D ç²’å­ç³»ç»Ÿ</title>
    <style>
        :root {
            --primary-color: #00f3ff;
            --glass-bg: rgba(20, 20, 35, 0.7);
            --glass-border: 1px solid rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }

        /* 3D Canvas */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay Container */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€åˆ° Canvas */
        }

        /* Common Panel Style */
        .panel {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: var(--glass-border);
            border-radius: 12px;
            padding: 15px;
            pointer-events: auto;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        /* Camera & Status Panel (Top Right) */
        #camera-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 220px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .video-wrapper {
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
        }

        #input_video {
            width: 100%;
            height: auto;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            display: block;
        }

        #status-text {
            margin-top: 10px;
            font-size: 14px;
            font-weight: bold;
            color: var(--primary-color);
            text-align: center;
            width: 100%;
            padding: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        /* Controls Panel (Left) */
        #controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 600;
        }

        .toggle-btn {
            font-size: 12px;
            opacity: 0.7;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #aaa;
        }

        /* Shape Buttons */
        .shape-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .shape-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 12px;
        }

        .shape-btn:hover, .shape-btn.active {
            background: var(--primary-color);
            color: black;
        }

        /* Color Picker */
        input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }

        /* Instructions (Bottom Center) */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            background: rgba(0,0,0,0.4);
            padding: 8px 16px;
            border-radius: 20px;
        }
        
        /* Loader */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: var(--primary-color);
            flex-direction: column;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid #333;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

    </style>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Import MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div>æ­£åœ¨åŠ è½½æ¨¡å‹...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <!-- Controls Panel -->
        <div id="controls-panel" class="panel">
            <div class="panel-header" onclick="togglePanel()">
                <span class="panel-title">ç²’å­æ§åˆ¶</span>
                <span class="toggle-btn" id="toggle-icon">â–¼</span>
            </div>
            <div id="panel-content">
                <div class="control-group">
                    <span class="control-label">é€‰æ‹©å½¢çŠ¶ (Templates)</span>
                    <div class="shape-grid">
                        <button class="shape-btn" onclick="setShape('heart')">â¤ï¸ çˆ±å¿ƒ</button>
                        <button class="shape-btn" onclick="setShape('flower')">ğŸŒ¸ èŠ±æœµ</button>
                        <button class="shape-btn" onclick="setShape('saturn')">ğŸª åœŸæ˜Ÿ</button>
                        <button class="shape-btn active" onclick="setShape('fireworks')">ğŸ† çƒŸèŠ±</button>
                    </div>
                </div>
                <div class="control-group">
                    <span class="control-label">ç²’å­é¢œè‰²</span>
                    <input type="color" id="color-picker" value="#00f3ff">
                </div>
            </div>
        </div>

        <!-- Camera Panel -->
        <div id="camera-panel" class="panel">
            <div class="video-wrapper">
                <video id="input_video"></video>
            </div>
            <div id="status-text">ç­‰å¾…æ‘„åƒå¤´...</div>
        </div>

        <!-- Instructions -->
        <div id="instructions">
            ğŸ–ï¸ å¼ å¼€ï¼šæ‰©å¼  | âœŠ æ¡æ‹³ï¼šæ”¶ç¼© | ğŸ‘Œ æåˆï¼šæ—‹è½¬ | ğŸ‘ ç«–å¤§æ‹‡æŒ‡ï¼šåˆ‡æ¢å½¢çŠ¶
        </div>
    </div>

    <script>
        // --- 1. å…¨å±€å˜é‡ä¸é…ç½® ---
        const PARTICLE_COUNT = 15000;
        const CAMERA_FOV = 60;
        
        let scene, camera, renderer, particles;
        let positions, targetPositions;
        let currentShape = 'fireworks';
        
        // äº¤äº’çŠ¶æ€
        let isExpanded = false;
        let isShrinking = false;
        let rotationSpeed = 0.002;
        let baseScale = 1.0;
        
        // æ‰‹åŠ¿åˆ‡æ¢é˜²æŠ–
        let lastSwitchTime = 0;
        const SWITCH_COOLDOWN = 2000; // 2ç§’

        // å½¢çŠ¶æ•°æ®ç¼“å­˜
        const geometries = {
            fireworks: [],
            heart: [],
            flower: [],
            saturn: []
        };

        // --- 2. Three.js åˆå§‹åŒ– ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // æ·»åŠ ä¸€ç‚¹è¿·é›¾æ•ˆæœ
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(CAMERA_FOV, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // é¢„è®¡ç®—æ‰€æœ‰å½¢çŠ¶çš„åæ ‡
            precalculateGeometries();

            // åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            
            // åˆå§‹è®¾ä¸ºçƒŸèŠ±(çƒä½“)å½¢çŠ¶
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] = geometries[currentShape][i];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // æè´¨
            const material = new THREE.PointsMaterial({
                color: 0x00f3ff,
                size: 0.8,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // ç›‘å¬é¢œè‰²å˜åŒ–
            document.getElementById('color-picker').addEventListener('input', (e) => {
                particles.material.color.set(e.target.value);
            });

            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }

        // --- 3. å‡ ä½•å½¢çŠ¶è®¡ç®— ---
        function precalculateGeometries() {
            // 1. çƒŸèŠ± (çƒä½“/éšæœºæ•£å¸ƒ)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = getSpherePoint(40);
                geometries.fireworks.push(p.x, p.y, p.z);
            }

            // 2. çˆ±å¿ƒ
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = getHeartPoint();
                geometries.heart.push(p.x, p.y, p.z);
            }

            // 3. èŠ±æœµ
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = getFlowerPoint();
                geometries.flower.push(p.x, p.y, p.z);
            }

            // 4. åœŸæ˜Ÿ
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = getSaturnPoint(i);
                geometries.saturn.push(p.x, p.y, p.z);
            }
        }

        // æ•°å­¦å…¬å¼ï¼šçƒä½“
        function getSpherePoint(radius) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            return {
                x: radius * Math.sin(phi) * Math.cos(theta),
                y: radius * Math.sin(phi) * Math.sin(theta),
                z: radius * Math.cos(phi)
            };
        }

        // æ•°å­¦å…¬å¼ï¼š3D çˆ±å¿ƒ
        function getHeartPoint() {
            // è¿™é‡Œä½¿ç”¨ä¸€ä¸ªå¸¸è§çš„3Då¿ƒå½¢å…¬å¼ï¼Œç¨å¾®åŠ ä¸€ç‚¹éšæœºæ‰°åŠ¨å¡«å……å†…éƒ¨
            const r = 2.5; // ç¼©æ”¾ç³»æ•°
            let x, y, z;
            // Rejection sampling for volume
            while(true) {
                 x = (Math.random() * 4 - 2) * r;
                 y = (Math.random() * 4 - 2) * r;
                 z = (Math.random() * 4 - 2) * r;
                 
                 // Heart formula (approximate)
                 const a = x*x + 9/4*y*y + z*z - 100; // Adjusted constant for size
                 // è¿™æ˜¯ä¸€ä¸ªæ›´ç®€å•çš„å‚æ•°æ–¹ç¨‹
                 // x = 16sin^3(t)
                 // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                 // z = varying
            }
            // ä½¿ç”¨å‚æ•°æ–¹ç¨‹ç”Ÿæˆè¡¨é¢ï¼Œç„¶ååŠ éšæœº
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;
            
            // ä¿®æ­£çš„å¿ƒå½¢å…¬å¼
            const t = phi; 
            const u = theta;
            
            // Heart shape parametric
            // x = 16 sin^3(t)
            // y = 13 cos(t) - 5 cos(2t) - 2 cos(3t) - cos(4t)
            // z = z 
            
            // è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„åˆ†å¸ƒç»„åˆ
            const range = 40;
            const x1 = (Math.random() - 0.5) * 2;
            const y1 = (Math.random() - 0.5) * 2;
            const z1 = (Math.random() - 0.5) * 2;
            
            // ç®€å•çš„æ•°å­¦æŠŠæˆï¼š
            const xx = Math.random() * Math.PI * 2;
            const yy = -Math.PI/2 + Math.random() * Math.PI; // latitude
            
            // è¿™æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å¿ƒå½¢æ–¹ç¨‹
            let hx = 16 * Math.pow(Math.sin(xx), 3);
            let hy = 13 * Math.cos(xx) - 5 * Math.cos(2*xx) - 2 * Math.cos(3*xx) - Math.cos(4*xx);
            let hz = z1 * 10; 
            
            // è®©å®ƒæ›´æœ‰ä½“ç§¯æ„Ÿ
            const scale = (Math.random() * 0.5 + 0.5) * 1.5;
            
            return { x: hx * scale, y: hy * scale, z: hz };
        }

        // æ•°å­¦å…¬å¼ï¼šèŠ±æœµ
        function getFlowerPoint() {
            const r = 30;
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI;
            // æ‰°åŠ¨åŠå¾„ä»¥å½¢æˆèŠ±ç“£
            const dr = Math.sin(u * 5) * 10; 
            const finalR = r + dr;
            
            return {
                x: finalR * Math.sin(v) * Math.cos(u),
                y: finalR * Math.sin(v) * Math.sin(u),
                z: finalR * Math.cos(v) * (Math.random() * 0.5 + 0.5)
            };
        }

        // æ•°å­¦å…¬å¼ï¼šåœŸæ˜Ÿ
        function getSaturnPoint(index) {
            // 70% ç²’å­åšçƒä½“ï¼Œ30% åšå…‰ç¯
            if (index < PARTICLE_COUNT * 0.7) {
                return getSpherePoint(20);
            } else {
                const angle = Math.random() * Math.PI * 2;
                const dist = 35 + Math.random() * 15;
                return {
                    x: Math.cos(angle) * dist,
                    y: (Math.random() - 0.5) * 2, // æ‰å¹³çš„å…‰ç¯
                    z: Math.sin(angle) * dist
                };
            }
        }

        // --- 4. åŠ¨ç”»å¾ªç¯ä¸å˜å½¢é€»è¾‘ ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. æ—‹è½¬
            particles.rotation.y += rotationSpeed;
            particles.rotation.x += rotationSpeed * 0.2;

            // 2. ç¼©æ”¾ (Lerp)
            let targetScale = baseScale;
            if (isShrinking) targetScale = 0.3;
            else if (isExpanded) targetScale = 1.6;
            
            particles.scale.setScalar(THREE.MathUtils.lerp(particles.scale.x, targetScale, 0.05));

            // 3. å˜å½¢ (Morphing)
            const currentPositions = particles.geometry.attributes.position.array;
            const targetData = geometries[currentShape];

            // ä¼˜åŒ–ï¼šæ¯æ¬¡åªæ›´æ–°ä¸€éƒ¨åˆ†ç²’å­ä»¥ä¿æŒé«˜å¸§ç‡ï¼Œæˆ–è€…æ ¹æ®æ€§èƒ½å…¨é‡æ›´æ–°
            // è¿™é‡Œä¸ºäº†å¹³æ»‘æ•ˆæœï¼Œä½¿ç”¨ç®€å•çš„é˜»å°¼è¿åŠ¨
            const speed = 0.08; 
            
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                // å½“å‰åæ ‡ += (ç›®æ ‡åæ ‡ - å½“å‰åæ ‡) * é€Ÿåº¦
                currentPositions[i] += (targetData[i] - currentPositions[i]) * speed;
                
                // æ·»åŠ ç”±äºæ‰‹åŠ¿æ‰©å¼ å¼•èµ·çš„é¢å¤–å™ªç‚¹
                if (isExpanded) {
                    currentPositions[i] += (Math.random() - 0.5) * 0.5;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 5. UI æ§åˆ¶é€»è¾‘ ---
        function togglePanel() {
            const content = document.getElementById('panel-content');
            const icon = document.getElementById('toggle-icon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.innerHTML = 'â–¼';
            } else {
                content.style.display = 'none';
                icon.innerHTML = 'â—€';
            }
        }

        function setShape(shape) {
            currentShape = shape;
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.shape-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function switchNextShape() {
            const shapes = Object.keys(geometries);
            let idx = shapes.indexOf(currentShape);
            idx = (idx + 1) % shapes.length;
            currentShape = shapes[idx];
            
            // Sync UI
            const btns = document.querySelectorAll('.shape-btn');
            btns.forEach(b => b.classList.remove('active'));
            btns[idx].classList.add('active');
        }

        // --- 6. MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            const statusEl = document.getElementById('status-text');
            
            // é»˜è®¤çŠ¶æ€é‡ç½®
            isExpanded = false;
            isShrinking = false;
            rotationSpeed = 0.002;
            
            let status = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0]; // åªå–ç¬¬ä¸€åªæ‰‹
                
                // ç®€å•çš„æ‰‹åŠ¿é€»è¾‘è®¡ç®—
                
                // 1. è®¡ç®—æ‹‡æŒ‡å’Œé£ŸæŒ‡çš„è·ç¦» (Pinch) - ç”¨äºæ—‹è½¬é€Ÿåº¦æˆ–åˆ¤æ–­
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // 2. ç»Ÿè®¡ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°é‡ (ç²—ç•¥ç®—æ³•ï¼šæŒ‡å°–y < æŒ‡å…³èŠ‚y)
                // æ³¨æ„ï¼šMediaPipeåæ ‡ç³»ä¸­ yå‘ä¸‹å¢å¤§ï¼Œæ‰€ä»¥ä¸Šé¢æ˜¯æ›´å°çš„y
                let fingersUp = 0;
                // é£ŸæŒ‡åˆ°å°æŒ‡
                if (landmarks[8].y < landmarks[6].y) fingersUp++;
                if (landmarks[12].y < landmarks[10].y) fingersUp++;
                if (landmarks[16].y < landmarks[14].y) fingersUp++;
                if (landmarks[20].y < landmarks[18].y) fingersUp++;
                // æ‹‡æŒ‡åˆ¤æ–­ (xè½´æ¯”è¾ƒ)
                // éœ€è¦åŒºåˆ†å·¦å³æ‰‹ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå‡è®¾å³æ‰‹ï¼Œå‘å·¦ä¼¸å‡º
                // æ›´ç¨³å¥çš„æ–¹æ³•æ˜¯çœ‹æ‹‡æŒ‡å°–å’ŒIPå…³èŠ‚çš„è·ç¦»
                
                // é€»è¾‘æ˜ å°„
                if (distance < 0.05) {
                    status = "ğŸ‘Œ æåˆ (æ—‹è½¬åŠ é€Ÿ)";
                    rotationSpeed = 0.05; // å¿«é€Ÿæ—‹è½¬
                } else if (fingersUp === 0) {
                    status = "âœŠ æ¡æ‹³ (æ”¶ç¼©)";
                    isShrinking = true;
                } else if (fingersUp >= 4) {
                    status = "ğŸ–ï¸ å¼ å¼€ (æ‰©å¼ )";
                    isExpanded = true;
                } else if (fingersUp === 1 && landmarks[4].y < landmarks[3].y) {
                    // åªæœ‰æ‹‡æŒ‡å’Œå…¶ä»–ä¸ä¸€æ ·ï¼Œæˆ–è€…å¤§æ‹‡æŒ‡æœä¸Š (Thumbs Up è¿‘ä¼¼)
                    // è¿™é‡Œåšä¸€ä¸ªç®€å•çš„ Thumbs Up æ£€æµ‹ï¼šæ‹‡æŒ‡å°–åœ¨æ‰€æœ‰æ‰‹æŒ‡æœ€ä¸Šæ–¹(yæœ€å°)ï¼Œä¸”å…¶ä»–æ‰‹æŒ‡å¼¯æ›²
                    status = "ğŸ‘ ç‚¹èµ (åˆ‡æ¢)";
                    const now = Date.now();
                    if (now - lastSwitchTime > SWITCH_COOLDOWN) {
                        switchNextShape();
                        lastSwitchTime = now;
                        // ç»™ä¸ªè§†è§‰åé¦ˆ
                        statusEl.style.color = '#ff0055';
                        setTimeout(() => statusEl.style.color = '#00f3ff', 500);
                    }
                } else {
                    status = "æ£€æµ‹ä¸­...";
                }
            }
            
            statusEl.innerText = status;
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('input_video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            
            cameraUtils.start();
        }

        // å¯åŠ¨ç¨‹åº
        window.onload = () => {
            initThree();
            initMediaPipe();
        };

    </script>
</body>
</html>